#+title: wallectl

walle 项目工具. 

* wallectl 简介

** generate 命令用于生成代码

** xlsx 命令用于生成配置
* wproto格式
wproto是在protobuf部分基础语法之上，进行扩展。
 - 支持自定义选项设置
 - 扩展的类型支持（int8，int16,uint8,uint16...）,用于生成代码
 - 更改service定义
 - 支持project定义
wproto不支持嵌套定义，继承。 
#+begin_quote
*定义消息名，字段名，选项时候，必须使用小写字母加下划线格式。*
#+end_quote

任何定义的结尾，“;” 都是可选的结束分隔符号。

** 注释及文档
因为wproto主要就是用于生成代码工具，所以编写时候，我希望将一些有用信息一起输出。
 - 单行文档： ~//~ 开头到行尾，会输出到插件，用于最终生成。
 - 多行文档： 以 ~/*~ 开头，以 ~*/~ 结尾，会输出到插件，用于最终生成。
 - 注释： ~#~ 开头，到行尾的注释，不会输出到插件。
** package name;
文件必须以package定义开头。可以有package的注释
#+begin_src protobuf
package pkg_name;
#+end_src

#+begin_src protobuf
// 包注释
package pkg_name
#+end_src
** import 定义
依赖其他文件的定义时，需要import。 必须包含文件名后缀。

#+begin_src protobuf
import "path/to/import.wproto"
import alias "path/to/import_def.wproto"
#+end_src

** option 定义
~option~ （自定义选项）必须是 aaa.bbb 格式。一般应以 “插件.选项” 定义。

选项的值支持字符串和数字(int64)。选项也可以不设置值，在插件中一般以bool值方式使用（是否设置了选项）。

~option~ 支持 文件级定义，消息级定义，字段级定义。

在文件内任何一行，

#+begin_src protobuf
// 无值的选项
example.opt1;
example.opt_switch

// 数字类型
exmaple.opt2 = 2;

// 字符串类型
exmaple.opt3 = "string options value";
example.opt4 = `string options value 2`;
#+end_src

** enum 定义
枚举默认以0开始，可以手动设置数值。
#+begin_src protobuf
// enum comment
enum enum_example
{
    // comment for val0, enum value default start by 0, ";"
    exmaple_val0;
    // custom set enum value
    example_val3 = 3
};
#+end_src

** message 定义
消息定义基本上和 ~protobuf~ 相同，修改如下
 - 添加了消息级和字段级的选项定义
 - 数组,字典类型支持go语法格式
字段类型：
  - int8,int16,int32,int64,uint8,uint16,uint32,uint64
  - string,bytes
  - bool
  - 数组： ~[]int32~ 等同于 ~repeated int32~
  - map: ~map[int32]int32~ 等同于 ~map<int32,int32>~
#+begin_src protobuf
// message define
message msg_name
{
    // 消息级选项定义
    example.opt_int = 5;
    // 选项注释
    example.opt_string = "string option value"
    // comment for msg_name.field_name 
    int32 field_name = 1;
    // protobuf 数组类型
    repeated int32 array_1 = 2;
    // go形式的数组
    []int32 array_2 = 3;
    // protobuf map
    map<int32,int32> map_value_1 = 5;
    // golang map
    map[int32][int32] map_value_2 = 6;

    // field with options
    string str_value = 10 {
        // 字段级选项
        example.field_option
        example.field_option_int = 10
        exmaple.field_option_str = "string option value"
    }
}
#+end_src

** service
服务是方法的集合。支持服务级选项定义，方法级选项定义。

方法定义(其中，‘[’ 和 ‘]’ 的部分是可选的)
#+begin_quote
方法名（ [参数消息类型名] ）[返回值消息类型名] [ = 接口序号 ] [{方法级选项定义}]
#+end_quote

接口序号，是开启 ~--use-method-id~ 选项后才可以使用。

#+begin_src protobuf
message rq {
    int32 a1 = 1;
    int32 a2 = 2;
}
message rs {
    int32 rv = 1;
}
service svr_name
{
    // 服务级选项配置
    example.svr_opt;
    example.svr_intopt = 1;
    example.svr_stropt = "string option value";
    // example 1: no args,no return value;
    example_f1();
    // example 2: args is rq meesage,no return value;
    example_f2(rq);
    // example 3: args is rq message,return rs message;
    example_f3(rq) rs;
    // 开启 --use-method-id 后，设置消息ID
    example_f4(r1) rs = 10;
    // 包含方法级选项
    example_f5(rq) rs {
        // 方法级选项定义
        example.opt;
        example.opt_int = 1;
        example.opt_str = "string value"
   }
}
#+end_src

** project
project 是options分组聚合配置。 ~map<string,[]option>~

#+begin_src protobuf
project proj_name
{
    // area 是自定义选项名称
area:
    example.opt1 = 1;
    example.opt2 = "string";

    // 可以有多个自定义区域 
another:
    example.v1;
    example.v2 = 4;
}
#+end_src

** 完整例子
#+begin_src protobuf
// package comment
package package_name;


import "path/to/import.wproto"
import alias "path/to/import_def.wproto"

// 包级option定义
go.pkg = "xx/xxx/xx"

// 无值的选项
example.opt1;
example.opt_switch

// 数字类型
exmaple.opt2 = 2;

// 字符串类型
exmaple.opt3 = "string options value";
example.opt4 = `string options value 2`;

// enum comment
enum enum_example
{
    // comment for val0, enum value default start by 0, ";"
    exmaple_val0;
    // custom set enum value
    example_val3 = 3
};

// message define
message msg_name
{
    // 消息级选项定义
    example.opt_int = 5;
    // 选项注释
    example.opt_string = "string option value"
    // comment for msg_name.field_name 
    int32 field_name = 1;
    // protobuf 数组类型
    repeated int32 array_1 = 2;
    // go形式的数组
    []int32 array_2 = 3;
    // protobuf map
    map<int32,int32> map_value_1 = 5;
    // golang map
    map[int32][int32] map_value_2 = 6;

    // field with options
    string str_value = 10 {
        // 字段级选项
        example.field_option
        example.field_option_int = 10
        exmaple.field_option_str = "string option value"
    }
}

message rq {
    int32 a1 = 1;
    int32 a2 = 2;
}
message rs {
    int32 rv = 1;
}
service svr_name
{
    // 服务级选项配置
    example.svr_opt;
    example.svr_intopt = 1;
    example.svr_stropt = "string option value";
    // example 1: no args,no return value;
    example_f1();
    // example 2: args is rq meesage,no return value;
    example_f2(rq);
    // example 3: args is rq message,return rs message;
    example_f3(rq) rs;
    // 开启 --use-method-id 后，设置消息ID
    example_f4(r1) rs = 10;
    // 包含方法级选项
    example_f5(rq) rs {
        // 方法级选项定义
        example.opt;
        example.opt_int = 1;
        example.opt_str = "string value"
   }
}

// project定义
project proj_name
{
    // area 是自定义选项名称
area:
    example.opt1 = 1;
    example.opt2 = "string";

    // 可以有多个自定义区域 
another:
    example.v1;
    example.v2 = 4;
}
#+end_src

* xlsx文档格式约定
** sheet格式 
要导出的sheet,只能以英文命名,不能有*汉字*,以后缀名区分不同表格类型.
*** _cfgs 结尾 - 多行数据表
前4行固定配置项,第5行开始是数据内容,会忽略空行. 用于生成结构体数组或者map.
 - 第一行 注释信息
 - 第二行 字段名称 sheet内不允许重名 只能写英文,以 ~#~ 开头,忽略本列
 - 第三行 字段类型 具体支持看下面文档
 - 第四行 数据约束 仅对当前列的数据进行约束,详细说明看下面文档.
*** _st 结尾 - 单条数据表
单个配置,只有一条配置的.用于 全局配置等. 用于生成单个结构体

单条数据表,是多行数据表的转置.

只读取前5列,后面的列都会忽略. 
*** _lua 结尾 - lua检测脚本表
只读取2列. 第一列 标签. 第二列 lua脚本. 会忽略空行.

** 字段类型
*** 基础类型
| 类型    | 字节(Byte) | 数值范围          |                     最小值 | 最大值                     | proto 对应 |
|---------+------------+-------------------+----------------------------+----------------------------+------------|
| int8    |          1 | -2^4 ~ 2^4-1      |                       -128 | 127                        | int32      |
| int16   |          2 | -2^15 ~ 2^15-1    |                    -32,768 | 32,767                     | int32      |
| int32   |          4 | -2^31 ~ 2^31-1    |             -2,147,483,648 | 2,147,483,647              | int32      |
| int64   |          8 | -2^63 ~ 2^63-1    | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  | int64      |
| uint8   |          1 | 0 ~ 2^8-1         |                          0 | 255                        | uint32     |
| uint16  |          2 | 0-2^16-1          |                          0 | 65535                      | uint32     |
| uint32  |          4 | 0-2^16-1          |                          0 | 4,294,967,295              | uint32     |
| uint64  |          8 | 0 ~ 2^64-1        |                          0 | 18,446,744,073,709,551,615 | uint64     |
| float32 |          4 | -3.4E-38~3.4E+38  |                   -3.4E-38 | 3.4E+38                    | float      |
| float64 |          8 | 1.7E-308~1.7E+308 |                   1.7E-308 | 1.7E+308                   | double     |
| bool    |            | 1,0,true,false    |                            |                            | bool       |
| string  |            |                   |                            |                            |            |

为了提供方便及缩减数据大小,提供以下别名 
 - int     等同 int32
 - uint32  等同 uint32
 - float   等同 float32
*** 容器类型
**** 数组类型
数组类型以 ~array<基础类型>~ 定义. 数据以 ~;~ 分隔.

例:

"1;3;4;"
**** 字典类型
字典类型以 ~map<key类型,value类型>~ 定义. 其中key类型为 *不包含float32,float64* 的基础类型. value可以是所有基础类型.

多个k/v对用 ~;~ 分隔. k/v 使用 ~:~ 分隔.

例:

"1:3;3:32"
** 字段数据约束
字段约束是对本列数据的检测.多个约束之间用 ~;~ 分隔
*** 数值类型检测
以下函数支持 所有数值类型,数组元素为数据类型的,map的value是数值类型的.
| 函数             | 含义                           |
|------------------+--------------------------------|
| values(n1,n2,..) | 数值必须是option定义的其中一个 |
| range(min,max)   | 数值必须在min,max中间          |
| min(n)           | 数值必须小于n                  |
| max(n)           | 数值必须大于n                  |
*** 容器类型检测
size 支持数组及map类型 
| 函数              | 含义                                                             |
|-------------------+------------------------------------------------------------------|
| size(min,max)     | 数据个数必须在min,max中间,如果只填1个数值,数据个数必须匹配此数值 |
*** map类型特定函数
针对map的key数值检测. 待开发 
** 检测脚本
所有sheet表,支持 "函数"
| 函数                                        | 含义                                                         | 返回值                      |
|---------------------------------------------+--------------------------------------------------------------+-----------------------------|
| sheet表名.字段名.range(function (data) end) | 遍历该表某个字段列的所有数值,data是string类型 表格的原始数据 | 无返回值                    |
| sheet表名.字段名.find(data)                 | 在该表中的某个字段下查找data数据,需要string类型的参数        | bool 是否查找到了对应的数据 |
| sheet表名.字段名.get(n)                     | 返回该表中的某个字段第n行的数据                              | string类型                  |
| error(tip1,tip2,...)                        | 查找出错之后写错误日志(非原始lua的error函数)                 | 无返回值                    |


